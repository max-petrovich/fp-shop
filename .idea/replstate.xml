<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1478880164988">{:repl-history {:ide [], :local [&quot;(+ 1 2\n   )&quot; &quot;(fn [] (+ 1 1))&quot; &quot;(defn maxic [x y] \n  (+ x y))&quot; &quot;(defn unrelax\n  [name]\n  (println (str \&quot;Hello, \&quot;, name)))&quot; &quot;(unrelax \&quot;maxic\&quot;)&quot; &quot;(unrelax #'\&quot;maxic\&quot;)&quot; &quot;(unrelax #\&quot;maxic\&quot;)&quot; &quot;(defn maxic\n  \&quot;My comment to func\&quot;\n  [name surname]\n  (println (str \&quot;Name: \&quot;, name, \&quot;, Surname: \&quot; surname)))&quot; &quot;(maxic \&quot;Maxim\&quot;, \&quot;Petrovich\&quot;)&quot; &quot;(doc maxic)&quot; &quot;(defn maxic-meta \n  \&quot;Comment\&quot;\n  {:added \&quot;1.0\&quot;\n   :static true}\n  [name]\n  (println (str \&quot;Hello\&quot; name)))&quot; &quot;(meta (var maxic-meta))&quot; &quot;(let [plus #(+ 1 %)]\n  (plus 10))&quot; &quot;#[name] (str name)&quot; &quot;(pr-str [1 2])&quot; &quot;(pr-str 1)&quot; &quot;(defn maxic\n  [one two]\n  (pr-str one two))&quot; &quot;(maxic 1 2 3)&quot; &quot;(maxic 1 2)&quot; &quot;(maxic 1 [3 4 5])&quot; &quot;(maxic (maxic 1 2) 3)&quot; &quot;(-&gt; []\n    (maxic 1 2))&quot; &quot;(-&gt; 3 4\n    (maxic 1 2))&quot; &quot;(-&gt; 1\n    (maxic 2))&quot; &quot;(-&gt; 1\n    (maxic 2)\n    (maxic 3))&quot; &quot;(-&gt; 1\n    (maxic 2)\n    (maxic 3)\n    (maxic 4))&quot; &quot;(defn plus\n  [one]\n  (+ 5 one))&quot; &quot;(plus 4)&quot; &quot;(-&gt; 2\n    (plus))&quot; &quot;(-&gt; 2\n    (plus 4))&quot; &quot;(-&gt; 2\n    (plus)\n    (plus))&quot; &quot;(-&gt;&gt; [\&quot;japan\&quot; \&quot;china\&quot; \&quot;korea\&quot;]\n     (map clojure.string/upper-case)\n     (map #(str \&quot;Hello\&quot; %)))&quot; &quot;(def latter (fn [] (+ 1 1)))&quot; &quot;(def latter2 (\n               fn \n               [] \n               (prn \&quot;Adding\&quot;)\n               (+ 1 2)))&quot; &quot;(latter2)&quot; &quot;#(+ 1 1)&quot; &quot;#(prn \&quot;Maxic\&quot;)&quot; &quot;#(prn name)&quot; &quot;#(prn name) [name]&quot; &quot;(def latter3 #(+ 1 3))&quot; &quot;(latter3)&quot; &quot;(defn latter4 #(prn name) [name])&quot; &quot;(defn latter4 #[name] (prn name))&quot; &quot;(defn latter4 #(prn arg1))&quot; &quot;(defn latter4 #(prn %1))&quot; &quot;(defn latter4 #(+ 1 %1))&quot; &quot;(def latter4 #(+ 1 %1))&quot; &quot;(latter 10)&quot; &quot;(latter)&quot; &quot;(def m1 #(+ 1 %))&quot; &quot;(m1 23)&quot; &quot;(def m2 #(prn %))&quot; &quot;(m2 \&quot;MAXIC\&quot;)&quot; &quot;(do\n  (Thread/sleep 3000)\n  (prn \&quot;hello\&quot;))&quot; &quot;(do\n  (future\n    (Thread/sleep 3000)\n    (println \&quot;after sleep\&quot;))\n  (println \&quot;hello\&quot;))&quot; &quot;(def my-promise (promise))&quot; &quot;(def listen-and-callback (fn []\n                           (prinln \&quot;Start listening...\&quot;)\n                           (future (println \&quot;Callback fired:\&quot; @my-promise))))&quot; &quot;(def listen-and-callback (fn []\n                           (println \&quot;Start listening...\&quot;)\n                           (future (println \&quot;Callback fired: \&quot; @my-promise))))&quot; &quot;(defn do-time-consuming-job []\n  (Thread/sleep 5000)\n  (deliver my-promise \&quot;delivered value\&quot;))&quot; &quot;(listen-and-callback) (do-time-consuming-job)&quot; &quot;(def atom-str (atom \&quot;Hello\&quot;))&quot; &quot;(atom-str)&quot; &quot;(def maxic 1)&quot; &quot;(def maxic 2)&quot; &quot;(def maxic #(+ 1 1))&quot; &quot;(def maxic #(+1 2))&quot; &quot;(def maxic #(+ 1 3))&quot; &quot;(maxic)&quot; &quot;(reset! atom-str \&quot;maxic\&quot;)&quot; &quot;@atom-str&quot; &quot;(def atom-int (atom 22))&quot; &quot;(swap! atom-int\n       (fn [current-atom]\n         (inc current-atom)))&quot; &quot;(swap! atom-int #(inc %))&quot; &quot;(swap! atom-int\n       (fn [_]))&quot; &quot;@atom-int&quot; &quot;(def x 10)&quot; &quot;(repeatedly 10\n            (fn [_] (def x (inc x))))&quot; &quot;(#'user/x...&quot; &quot;(repeatedly 10\n            (fn [] (def x (inc x))))\n(#'user/x...&quot; &quot;(repeatedly 10\n            (fn [] (def x (inc x))))&quot; &quot;(x)&quot; &quot;(def x 0)&quot; &quot;(repeatedly 10 \n            (fn [] (future (!swap x inc))))&quot; &quot;(def x (atom 10))&quot; &quot;(repeatedly 10\n            (fn [] (future (swap! x inc))))&quot; &quot;x&quot; &quot;(def user (ref {}))&quot; &quot;(dosync\n  (alter user merge {:name \&quot;Kim\&quot;})\n  (throw (Exception. \&quot;some wrong\&quot;))\n  (alter user merge {:age 32}))&quot; &quot;@user&quot; &quot;(def user-record (atom {}))&quot; &quot;(do\n  (swap! user-record merge {:name \&quot;Kim\&quot;})\n  (throw (Exception. \&quot;wrong\&quot;))\n  (swap! user-record merge {:age 32}))&quot; &quot;@user-record&quot; &quot;(def my-ref (ref 0))&quot; &quot;(future \n  (dosync \n    (alter my-ref inc)\n    (Thread/sleep 5000)))&quot; &quot;@my-ref&quot;], :remote []}}</component>
</project>